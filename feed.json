{"title":"SoulReader","description":"前端boys","language":"en","link":"https://fanghaimao.github.io","pubDate":"Fri, 20 Nov 2020 01:44:55 GMT","lastBuildDate":"Thu, 21 Jul 2022 06:59:24 GMT","generator":"hexo-generator-json-feed","webMaster":"mfh","items":[{"title":"《你不知道javascript》 知识点摘录","link":"https://fanghaimao.github.io/2020/11/20/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93javascript%E3%80%8B%20%E8%AF%BB%E5%90%8E%E6%84%9F/","description":"第一部分 类型和语法 &amp;&amp; 运算符的优先级高于 ||, 而 || 的优先级高于 ? :, &amp;&amp; || 是左关联， ? : 是右关联 在 try...catch...中，如果包含在for循环中，在一定情况下会在i++执行之前执行，如果在try...catch...中，加入yield, 由于yield的特性，try并未结束，因此catch、finally并不会立即执行 finally中的return会覆盖try和catch中的return的返回值 switch switch中的匹配算法是=== case 中的表达式尽量不要使用 &amp;&amp; or ||，因为匹配的数值并一定严格相等 判断字段类型 typeof instanceof Object.prototype.toString.call(obj) 再给html标签添加id标签的时候回默认添加一个和标签相同名称的全局变量 在script标签中是使用javascript语言，如果语句中包含&lt;/script&gt;则会被视为script标签的结束，应该使用&quot;&lt;/sc&quot; + &quot;ript&gt;&quot;来代替 第二部分 异步和性能 尽量避免发送同步的ajax请求，因为这样会锁定浏览器的UI,并且阻塞所用的用户交互 javascript从不跨线程共享数据 New Promise() Promise.all()Promise.all可以将多个Promise实例包装成一个新的Promise实例，同时，成功和失败的返回值是不同的, 成功的时候返回一个结果数据，失败的时候则最先被reject失败的状态的值 返回的成功的结果的数据顺序和Promise.all接收到的数组顺序是一致的如果有一个promise被拒绝， 主Promise.all()就会被立刻拒绝，并丢弃来自其他所有promise的全部结果 1234567891011121314function add(fun1, fun2) &#123; return Promise.all([fun1, fun2]).then(values =&gt; &#123; return values &#125;)&#125;const fun1 = new Promise((resolve, reject) =&gt; &#123; resolve(2) &#125;)const fun2 = new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)add(fun1, fun2).then(values =&gt; &#123; console.log(values) // [2, 4]&#125;) Promise.race Promise.race 竞赛模式 只要传入的数组里面那个结果先出来，就返回哪个结果（不论返回的接口是成功还是失败） 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;success&#x27;) &#125;,1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;failed&#x27;) &#125;, 500)&#125;)Promise.race([p1, p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 打开的是 &#x27;failed&#x27;&#125;) 调用Promise的then()时，只传入一个完全处理函数，一个默认拒绝处理函数就会顶替上来，把错误重新抛出，是的错误可以沿着Promise链传递下去，知道遇到显式定义的拒绝处理函数 Promise.finally 通常用来处理被丢弃或者忽略的promise, 如果有需要释放的资源可以在finally进行释放 Promise.none 所有的promise都被拒绝才返回 Promise.any 至少需要一个promise完成就返回 Promise.first 只要第一个Promise完成，后续任何拒绝和完成都会忽略 Promise.last 只有最后一个完成的Promise胜出 并发迭代 Promise.map 12345678910111213141516171819202122// 封装Promise.mapif(!Promise.map) &#123; Promise.map = function(vals, cb) &#123; return Promise.all( vals.map(function(val) &#123; return new Promise( function(resolve) &#123; cb(val, resolve) &#125;) &#125;) ) &#125;&#125;// 使用Promise.mapPromise.map([p1, p2, p3], function(pr, done) &#123; promise.resolve(pr).then((v) =&gt; &#123; done(v * 2) &#125;, done)&#125;).then((values) =&gt; &#123; console.log(values)&#125;) try...catch... 不能和Promise连用，try...catch...只有在同步的情况下才能捕捉到异常，任何异步的错误都将无法捕捉到 一些无效的使用Promise API: new Promise(null)、 Promise.all()、Promise.race(42) 生成器 function *foo()&#123; &#125; 定义生成器函数 123function *foo() &#123; // what to do...&#125; 调用生成器函数 123456789// 在此处创建了一个生成器foofunction *foo(x, y) &#123; return x + y&#125;// 创建一个的迭代器对象，将迭代器对象赋值给了变量itvar it = foo(3, 4)// 调用it.next() 指示生成器从当前的位置继续运行，停留在下一个yield或者生成器结束var res = it.next()res.value // 7 需要的next() 调用比yield语句多一个，因为第一个next()用来启动一个生成器，并运行到第一个yield处，第二个next()调用完第一个被暂停的yield表达式，第三个next()调用完成第二个yield，依次类推 可以通过next向yield表达式传值 yield 和 next()组合起来，在生成器的执行过程中，构成了一个双向消息传递系统 12345678910function *foo(x) &#123; var y = x * (yield &quot;hello&quot;) return y&#125;var it = foo(6) //初始化一个迭代器 itvar res = it.next()res.value // hellovar res = it.next(7)res.value // 42 最后一个next()由return来回答 value为return 出来的值，如果生成器中没有return，会有一个假定的，隐式的return，会在默认的情况下回答最后的next()调用提出的问题 多个迭代器 12345678910111213141516171819202122232425262728293031function *foo() &#123; var x = yield 2 z++ console.log(z, &#x27;z&#x27;) var y = yield (x * z) console.log(x,y,z)&#125;var z = 1var it1 = foo() // 第一个迭代器var it2 = foo() // 第二个迭代器var val1 = it1.next().valuevar val2 = it2.next().valueconsole.log(val1, val2, &quot;val1, val2&quot;)val1 = it1.next(val2 * 10).valueval2 = it2.next(val1 * 5).valueconsole.log(val1, val2, &quot;val1, val2, two&quot;)it1.next(val2 / 2)it2.next(val1 / 4)// console// 2 2 val1, val2// 2 z// 3 z// 40 600 val1, val2, two// 20 300 3// 200 10 3 多个迭代器交互的时候，生成器中包含有全局变量时，会对全局变量造成污染 可以用于记录函数生成的最后一个值 1234567891011121314151617181920var something = (function () &#123; var nextVal return &#123; [Symbol.interator]: function() &#123; return this &#125;, next: function() &#123; if(nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = (3 * nextVal) + 6 &#125; return &#123;done: false, value: nextVal&#125; &#125; &#125;&#125;)()something.next().value // 1something.next().value // 9something.next().value // 33 es6新增了一个for ... of ...循环，意味着可以通过原生循环语法自动贴袋标准迭代器 123456for (var v of something) &#123; console.log(v) if(v &gt; 10) &#123; break; &#125;&#125; 终止生成器 for ... of ... 循环内的break会触发finally语句，终止生成器，也可以在外部调用it.return(..)手动终止生成器的迭代器实例 调用it.return之后会立刻终止生成器，运行finally语句","pubDate":"Fri, 20 Nov 2020 01:44:55 GMT","guid":"https://fanghaimao.github.io/2020/11/20/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93javascript%E3%80%8B%20%E8%AF%BB%E5%90%8E%E6%84%9F/","category":"读后感"}]}