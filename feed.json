{"title":"SoulReader","description":"前端boys","language":"en","link":"https://fanghaimao.github.io","pubDate":"Wed, 08 Feb 2023 02:42:20 GMT","lastBuildDate":"Wed, 08 Feb 2023 03:08:27 GMT","generator":"hexo-generator-json-feed","webMaster":"mfh","items":[{"title":"JavaScript线程解释","link":"https://fanghaimao.github.io/2023/02/08/JavaScript%E7%BA%BF%E7%A8%8B%E8%A7%A3%E9%87%8A/","description":"JavaScript线程解释 Event Loop 机制 js 怎么实现异步 ? 通过浏览器内核多线程实现异步。 当我们启动浏览器的时候就启动了多个进程。 一个进程包含多个线程。 当然我们所要关心的是渲染进程，渲染进程是浏览器的核心进程。 GUI 线程：负责渲染页面，解析 html、css；构建 DOM 树和渲染树 js 引擎线程： js 引擎线程负责解析和执行 js 程序，我们经常听到的 chrome 的 v8 引擎就是跑在 js 引擎线程上的，js 引擎线程只有一个，所有说 js 的单线程语言的原因，那其实语言没有单线程多线程之说，因为解释这个语言的是 的线程是单线程；js 引擎线程与 gui 线程互斥，当浏览器执行 javaScript 程序的时候，GUI 渲染线层会保存在一个队列当中；直到 js 程序执行完成，才会接着执行；如果 js 的执行时间过长，会影响页面的渲染不连贯，所有我们要尽量控制 js 的大小 定时触发线程：为什么 setTimeout 不阻塞后面程序的运行，那其实 setTimeout 不是由 js 引擎线程完成的，是由定时器触发线程完成的，所以它们可以是同时进行的，那么定时器触发线程在这定时任务完成之后会通知事件触发线程往任务队列里添加事件 事件触发线程：将满足触发条件的事件放入任务队列，一些异步的事件会放到异步队列中 异步 HTTP 请求线程：用与处理 ajax 请求的，当请求完成时如果有回调函数就通知事件触发线程往任务队列中添加任务 Event Loop 机制 &nbsp; &nbsp; Event Loop 是什么？ &nbsp; &nbsp; Event Loop 是一个程序结构，用于等待和发送信息的事件。 简单说就是在程序中设置 2 个线程，一个负责程序本身的运行，称为“主线程”；另一个负责主线程和其他进程（主要是各种 I/O 操作）的通信 被称为“Event Loop 线程”（也可以翻译为消息线层） 浏览器的 Event Loop &nbsp; &nbsp; 宏观：浏览器多线程（从宏观来看是多线程实现了异步） &nbsp; &nbsp; 微观：Event Loop，事件循环（Event Loop 翻译是事件循环，是实现异步的一种机制） 有 3 个点要注意 &nbsp; &nbsp; 我们整个大的 script 的执行是全局任务也是一个宏任务的范畴，当宏任务执行完，会去执行所有的微任务，微任务全部执行完在去执行下一个宏任务，那什么时候去执行一个微任务呢，是等调用栈为空的时候， 调用栈不为空的时候，任务队列的微任务一直等待；微任务执行完又去取任务队列里的宏任务，去依次 执行宏任务，执行宏任务的时候就要检查当前有没有微任务，如果有微任务就去执行完所有微任务，然后 再去执行后续的宏任务 参考资料 https://senior-frontend.pages.dev/jsadvanced/asyncpro.html","pubDate":"Wed, 08 Feb 2023 02:42:20 GMT","guid":"https://fanghaimao.github.io/2023/02/08/JavaScript%E7%BA%BF%E7%A8%8B%E8%A7%A3%E9%87%8A/","category":"读后感"},{"title":"前端提升网址推荐","link":"https://fanghaimao.github.io/2023/02/07/%E5%89%8D%E7%AB%AF%E6%8F%90%E5%8D%87%E7%BD%91%E5%9D%80%E6%8E%A8%E8%8D%90/","description":"全栈网址推荐 web全栈体系 https://senior-frontend.pages.dev/ 前端知识总结 https://leohxj.gitbooks.io/front-end-database/content/interview/skill-path.html","pubDate":"Tue, 07 Feb 2023 01:44:55 GMT","guid":"https://fanghaimao.github.io/2023/02/07/%E5%89%8D%E7%AB%AF%E6%8F%90%E5%8D%87%E7%BD%91%E5%9D%80%E6%8E%A8%E8%8D%90/","category":"读后感"},{"title":"《你不知道javascript》 知识点摘录","link":"https://fanghaimao.github.io/2020/11/20/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93javascript%E3%80%8B%20%E8%AF%BB%E5%90%8E%E6%84%9F/","description":"第一部分 类型和语法 &amp;&amp; 运算符的优先级高于 ||, 而 || 的优先级高于 ? :, &amp;&amp; || 是左关联， ? : 是右关联 在 try...catch...中，如果包含在for循环中，在一定情况下会在i++执行之前执行，如果在try...catch...中，加入yield, 由于yield的特性，try并未结束，因此catch、finally并不会立即执行 finally中的return会覆盖try和catch中的return的返回值 switch switch中的匹配算法是=== case 中的表达式尽量不要使用 &amp;&amp; or ||，因为匹配的数值并一定严格相等 判断字段类型 typeof instanceof Object.prototype.toString.call(obj) 再给html标签添加id标签的时候回默认添加一个和标签相同名称的全局变量 在script标签中是使用javascript语言，如果语句中包含&lt;/script&gt;则会被视为script标签的结束，应该使用&quot;&lt;/sc&quot; + &quot;ript&gt;&quot;来代替 第二部分 异步和性能 尽量避免发送同步的ajax请求，因为这样会锁定浏览器的UI,并且阻塞所用的用户交互 javascript从不跨线程共享数据 New Promise() Promise.all()Promise.all可以将多个Promise实例包装成一个新的Promise实例，同时，成功和失败的返回值是不同的, 成功的时候返回一个结果数据，失败的时候则最先被reject失败的状态的值 返回的成功的结果的数据顺序和Promise.all接收到的数组顺序是一致的如果有一个promise被拒绝， 主Promise.all()就会被立刻拒绝，并丢弃来自其他所有promise的全部结果 1234567891011121314function add(fun1, fun2) &#123; return Promise.all([fun1, fun2]).then(values =&gt; &#123; return values &#125;)&#125;const fun1 = new Promise((resolve, reject) =&gt; &#123; resolve(2) &#125;)const fun2 = new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)add(fun1, fun2).then(values =&gt; &#123; console.log(values) // [2, 4]&#125;) Promise.race Promise.race 竞赛模式 只要传入的数组里面那个结果先出来，就返回哪个结果（不论返回的接口是成功还是失败） 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;success&#x27;) &#125;,1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;failed&#x27;) &#125;, 500)&#125;)Promise.race([p1, p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 打开的是 &#x27;failed&#x27;&#125;) 调用Promise的then()时，只传入一个完全处理函数，一个默认拒绝处理函数就会顶替上来，把错误重新抛出，是的错误可以沿着Promise链传递下去，知道遇到显式定义的拒绝处理函数 Promise.finally 通常用来处理被丢弃或者忽略的promise, 如果有需要释放的资源可以在finally进行释放 Promise.none 所有的promise都被拒绝才返回 Promise.any 至少需要一个promise完成就返回 Promise.first 只要第一个Promise完成，后续任何拒绝和完成都会忽略 Promise.last 只有最后一个完成的Promise胜出 并发迭代 Promise.map 12345678910111213141516171819202122// 封装Promise.mapif(!Promise.map) &#123; Promise.map = function(vals, cb) &#123; return Promise.all( vals.map(function(val) &#123; return new Promise( function(resolve) &#123; cb(val, resolve) &#125;) &#125;) ) &#125;&#125;// 使用Promise.mapPromise.map([p1, p2, p3], function(pr, done) &#123; promise.resolve(pr).then((v) =&gt; &#123; done(v * 2) &#125;, done)&#125;).then((values) =&gt; &#123; console.log(values)&#125;) try...catch... 不能和Promise连用，try...catch...只有在同步的情况下才能捕捉到异常，任何异步的错误都将无法捕捉到 一些无效的使用Promise API: new Promise(null)、 Promise.all()、Promise.race(42) 生成器 function *foo()&#123; &#125; 定义生成器函数 123function *foo() &#123; // what to do...&#125; 调用生成器函数 123456789// 在此处创建了一个生成器foofunction *foo(x, y) &#123; return x + y&#125;// 创建一个的迭代器对象，将迭代器对象赋值给了变量itvar it = foo(3, 4)// 调用it.next() 指示生成器从当前的位置继续运行，停留在下一个yield或者生成器结束var res = it.next()res.value // 7 需要的next() 调用比yield语句多一个，因为第一个next()用来启动一个生成器，并运行到第一个yield处，第二个next()调用完第一个被暂停的yield表达式，第三个next()调用完成第二个yield，依次类推 可以通过next向yield表达式传值 yield 和 next()组合起来，在生成器的执行过程中，构成了一个双向消息传递系统 12345678910function *foo(x) &#123; var y = x * (yield &quot;hello&quot;) return y&#125;var it = foo(6) //初始化一个迭代器 itvar res = it.next()res.value // hellovar res = it.next(7)res.value // 42 最后一个next()由return来回答 value为return 出来的值，如果生成器中没有return，会有一个假定的，隐式的return，会在默认的情况下回答最后的next()调用提出的问题 多个迭代器 12345678910111213141516171819202122232425262728293031function *foo() &#123; var x = yield 2 z++ console.log(z, &#x27;z&#x27;) var y = yield (x * z) console.log(x,y,z)&#125;var z = 1var it1 = foo() // 第一个迭代器var it2 = foo() // 第二个迭代器var val1 = it1.next().valuevar val2 = it2.next().valueconsole.log(val1, val2, &quot;val1, val2&quot;)val1 = it1.next(val2 * 10).valueval2 = it2.next(val1 * 5).valueconsole.log(val1, val2, &quot;val1, val2, two&quot;)it1.next(val2 / 2)it2.next(val1 / 4)// console// 2 2 val1, val2// 2 z// 3 z// 40 600 val1, val2, two// 20 300 3// 200 10 3 多个迭代器交互的时候，生成器中包含有全局变量时，会对全局变量造成污染 可以用于记录函数生成的最后一个值 1234567891011121314151617181920var something = (function () &#123; var nextVal return &#123; [Symbol.interator]: function() &#123; return this &#125;, next: function() &#123; if(nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = (3 * nextVal) + 6 &#125; return &#123;done: false, value: nextVal&#125; &#125; &#125;&#125;)()something.next().value // 1something.next().value // 9something.next().value // 33 es6新增了一个for ... of ...循环，意味着可以通过原生循环语法自动贴袋标准迭代器 123456for (var v of something) &#123; console.log(v) if(v &gt; 10) &#123; break; &#125;&#125; 终止生成器 for ... of ... 循环内的break会触发finally语句，终止生成器，也可以在外部调用it.return(..)手动终止生成器的迭代器实例 调用it.return之后会立刻终止生成器，运行finally语句","pubDate":"Fri, 20 Nov 2020 01:44:55 GMT","guid":"https://fanghaimao.github.io/2020/11/20/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93javascript%E3%80%8B%20%E8%AF%BB%E5%90%8E%E6%84%9F/","category":"读后感"}]}